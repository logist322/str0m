Index: examples/chat.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/chat.rs b/examples/chat.rs
--- a/examples/chat.rs	(revision f371a68181237d783b07eb2f1d1d694b29476546)
+++ b/examples/chat.rs	(date 1704804358778)
@@ -1,11 +1,9 @@
 #[macro_use]
 extern crate tracing;
 
-use std::collections::VecDeque;
 use std::io::ErrorKind;
-use std::net::{IpAddr, SocketAddr, UdpSocket};
+use std::net::{SocketAddr, UdpSocket};
 use std::ops::Deref;
-use std::os::unix::process::parent_id;
 use std::sync::atomic::{AtomicU64, Ordering};
 use std::sync::mpsc::{self, Receiver, SyncSender, TryRecvError};
 use std::sync::{Arc, Weak};
@@ -16,12 +14,12 @@
 use rouille::{Request, Response};
 use str0m::change::{SdpAnswer, SdpOffer, SdpPendingOffer};
 use str0m::channel::{ChannelData, ChannelId};
-use str0m::media::{Direction, KeyframeRequest, MediaData, Mid, Rid};
 use str0m::media::{KeyframeRequestKind, MediaKind};
+use str0m::media::{Direction, KeyframeRequest, MediaData, Mid, Rid};
+use str0m::Event;
+use str0m::{net::Receive, Candidate, IceConnectionState, Input, Output, Rtc, RtcError};
 use str0m::net::Protocol;
 use str0m::rtp::RtpPacket;
-use str0m::{net::Receive, Candidate, Event, IceConnectionState, Input, Output, Rtc, RtcError};
-use systemstat::{data, Ipv4Addr};
 
 mod util;
 
@@ -47,13 +45,13 @@
 
     // Figure out some public IP address, since Firefox will not accept 127.0.0.1 for WebRTC traffic.
     // let host_addr = util::select_host_address();
-    let host_addr = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 81));
+    // let host_addr = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 81));
 
     let (tx, rx) = mpsc::sync_channel(1);
 
     // Spin up a UDP socket for the RTC. All WebRTC traffic is going to be multiplexed over this single
     // server socket. Clients are identified via their respective remote (UDP) socket address.
-    let socket = UdpSocket::bind(format!("{host_addr}:0")).expect("binding a random UDP port");
+    let socket = UdpSocket::bind(format!("127.0.0.1:0")).expect("binding a random UDP port");
     let addr = socket.local_addr().expect("a local socket adddress");
     info!("Bound UDP port: {}", addr);
 
@@ -110,7 +108,6 @@
 /// and forwards media data between clients.
 fn run(socket: UdpSocket, rx: Receiver<Rtc>) -> Result<(), RtcError> {
     let mut clients: Vec<Client> = vec![];
-    let mut to_propagate: VecDeque<Propagated> = VecDeque::new();
     let mut buf = vec![0; 2000];
 
     loop {
@@ -128,24 +125,12 @@
             clients.push(client);
         }
 
-        // Poll clients until they return timeout
-        let mut timeout = Instant::now() + Duration::from_millis(100);
-        for client in clients.iter_mut() {
-            let t = poll_until_timeout(client, &mut to_propagate, &socket);
-            timeout = timeout.min(t);
-        }
-
-        // If we have an item to propagate, do that
-        if let Some(p) = to_propagate.pop_front() {
-            propagate(&p, &mut clients);
-            continue;
-        }
-
-        // The read timeout is not allowed to be 0. In case it is 0, we set 1 millisecond.
-        let duration = (timeout - Instant::now()).max(Duration::from_millis(1));
+        // Poll all clients, and get propagated events as a result.
+        let to_propagate: Vec<_> = clients.iter_mut().map(|c| c.poll_output(&socket)).flatten().collect();
+        propagate(&mut clients, to_propagate);
 
         socket
-            .set_read_timeout(Some(duration))
+            .set_read_timeout(Some(Duration::from_micros(10)))
             .expect("setting socket read timeout");
 
         if let Some(input) = read_socket_input(&socket, &mut buf) {
@@ -179,60 +164,33 @@
     }
 }
 
-/// Poll all the output from the client until it returns a timeout.
-/// Collect any output in the queue, transmit data on the socket, return the timeout
-fn poll_until_timeout(
-    client: &mut Client,
-    queue: &mut VecDeque<Propagated>,
-    socket: &UdpSocket,
-) -> Instant {
-    loop {
-        if !client.rtc.is_alive() {
-            // This client will be cleaned up in the next run of the main loop.
-            info!("bbbbbbbbbbbbbbbbbbbbbbbbbbb");
-            return Instant::now();
-        }
-
-        let propagated = client.poll_output(socket);
-
-        if let Propagated::Timeout(t) = propagated {
-            return t;
-        }
-
-        queue.push_back(propagated)
-    }
-}
-
-/// Sends one "propagated" to all clients, if relevant
-fn propagate(propagated: &Propagated, clients: &mut [Client]) {
-    // Do not propagate to originating client.
-    let Some(client_id) = propagated.client_id() else {
-        // If the event doesn't have a client id, it can't be propagated,
-        // (it's either a noop or a timeout).
-        return;
-    };
+fn propagate(clients: &mut [Client], to_propagate: Vec<Propagated>) {
+    for propagated in to_propagate {
+        let Some(client_id) = propagated.client_id() else {
+            // If the event doesn't have a client id, it can't be propagated,
+            // (it's either a noop or a timeout).
+            continue;
+        };
 
-    for client in &mut *clients {
-        if client.id == client_id {
-            // Do not propagate to originating client.
-            continue;
-        }
+        for client in &mut *clients {
+            if client.id == client_id {
+                // Do not propagate to originating client.
+                continue;
+            }
 
-        match &propagated {
-            Propagated::TrackOpen(_, track_in) => client.handle_track_open(track_in.clone()),
-            Propagated::MediaData(_, data) => client.handle_media_data_out(client_id, data),
-            Propagated::KeyframeRequest(_, req, origin, mid_in) => {
-                // Only one origin client handles the keyframe request.
-                if *origin == client.id {
-                    client.handle_keyframe_request(*req, *mid_in)
-                }
-            }
-            Propagated::Noop => {
-                info!("vvvvvvvvvvvvvvvvvvvvv");
-            }
-            Propagated::Timeout(_) => {}
-            Propagated::RtpPacket(_, packet) => {
-                client.handle_packet(client_id, packet);
+            match &propagated {
+                Propagated::TrackOpen(_, track_in) => client.handle_track_open(track_in.clone()),
+                Propagated::MediaData(_, data) => client.handle_media_data_out(client_id, data),
+                Propagated::KeyframeRequest(_, req, origin, mid_in) => {
+                    // Only one origin client handles the keyframe request.
+                    if *origin == client.id {
+                        client.handle_keyframe_request(*req, *mid_in)
+                    }
+                }
+                Propagated::RtpPacket(_, packet) => {
+                    client.handle_packet(client_id, packet)
+                }
+                Propagated::Noop | Propagated::Timeout(_) => {}
             }
         }
     }
@@ -357,74 +315,80 @@
         }
     }
 
-    fn poll_output(&mut self, socket: &UdpSocket) -> Propagated {
+    fn poll_output(&mut self, socket: &UdpSocket) -> Vec<Propagated> {
         if !self.rtc.is_alive() {
-            return Propagated::Noop;
+            return vec![Propagated::Noop];
         }
 
         // Incoming tracks from other clients cause new entries in track_out that
         // need SDP negotiation with the remote peer.
         if self.negotiate_if_needed() {
-            return Propagated::Noop;
+            return vec![Propagated::Noop];
         }
 
-        match self.rtc.poll_output() {
-            Ok(output) => self.handle_output(output, socket),
-            Err(e) => {
-                warn!("Client ({}) poll_output failed: {:?}", *self.id, e);
-                self.rtc.disconnect();
-                Propagated::Noop
-            }
-        }
-    }
-
-    fn handle_output(&mut self, output: Output, socket: &UdpSocket) -> Propagated {
-        match output {
-            Output::Transmit(transmit) => {
-                // info!("transmiiiiit {transmit:?}");
-                socket
-                    .send_to(&transmit.contents, transmit.destination)
-                    .expect("sending UDP data");
-                Propagated::Noop
-            }
-            Output::Timeout(t) => Propagated::Timeout(t),
-            Output::Event(e) => match e {
-                Event::IceConnectionStateChange(v) => {
-                    if v == IceConnectionState::Disconnected {
-                        // Ice disconnect could result in trying to establish a new connection,
-                        // but this impl just disconnects directly.
-                        self.rtc.disconnect();
-                    }
-                    Propagated::Noop
-                }
-                Event::MediaAdded(e) => self.handle_media_added(e.mid, e.kind),
-                Event::MediaData(data) => self.handle_media_data_in(data),
-                Event::KeyframeRequest(req) => self.handle_incoming_keyframe_req(req),
-                Event::ChannelOpen(cid, _) => {
-                    self.cid = Some(cid);
-                    Propagated::Noop
-                }
-                Event::ChannelData(data) => self.handle_channel_data(data),
+        let mut propagate = Vec::new();
+        loop {
+            match self.rtc.poll_output() {
+                Ok(output) => {
+                    let p = match output {
+                        Output::Transmit(transmit) => {
+                            socket
+                                .send_to(&transmit.contents, transmit.destination)
+                                .expect("sending UDP data");
+                            Propagated::Noop
+                        }
+                        Output::Timeout(t) => {
+                            propagate.push(Propagated::Timeout(t));
+
+                            return propagate;
+                        },
+                        Output::Event(e) => match e {
+                            Event::IceConnectionStateChange(v) => {
+                                if v == IceConnectionState::Disconnected {
+                                    // Ice disconnect could result in trying to establish a new connection,
+                                    // but this impl just disconnects directly.
+                                    self.rtc.disconnect();
+                                }
+                                Propagated::Noop
+                            }
+                            Event::MediaAdded(e) => self.handle_media_added(e.mid, e.kind),
+                            Event::KeyframeRequest(req) => self.handle_incoming_keyframe_req(req),
+                            Event::ChannelOpen(cid, _) => {
+                                self.cid = Some(cid);
+                                Propagated::Noop
+                            }
+                            Event::ChannelData(data) => self.handle_channel_data(data),
 
-                // NB: To see statistics, uncomment set_stats_interval() above.
-                Event::MediaIngressStats(data) => {
-                    info!("{:?}", data);
-                    Propagated::Noop
-                }
-                Event::MediaEgressStats(data) => {
-                    info!("{:?}", data);
-                    Propagated::Noop
-                }
-                Event::PeerStats(data) => {
-                    info!("{:?}", data);
-                    Propagated::Noop
-                }
-                Event::RtpPacket(data) => {
-                    info!("propadated packetttttttttttt");
-                    Propagated::RtpPacket(self.id, data)
-                }
-                _ => Propagated::Noop,
-            },
+                            // NB: To see statistics, uncomment set_stats_interval() above.
+                            Event::MediaIngressStats(data) => {
+                                info!("{:?}", data);
+                                Propagated::Noop
+                            }
+                            Event::MediaEgressStats(data) => {
+                                info!("{:?}", data);
+                                Propagated::Noop
+                            }
+                            Event::PeerStats(data) => {
+                                info!("{:?}", data);
+                                Propagated::Noop
+                            }
+                            Event::RtpPacket(data) => {
+                                Propagated::RtpPacket(self.id, data)
+                            }
+                            _ => {
+                                Propagated::Noop
+                            }
+                        },
+                    };
+
+                    propagate.push(p);
+                },
+                Err(e) => {
+                    warn!("Client ({}) poll_output failed: {:?}", *self.id, e);
+                    self.rtc.disconnect();
+                    return Vec::new();
+                }
+            }
         }
     }
 
@@ -446,41 +410,6 @@
         Propagated::TrackOpen(self.id, weak)
     }
 
-    fn handle_media_data_in(&mut self, data: MediaData) -> Propagated {
-        if !data.contiguous {
-            self.request_keyframe_throttled(data.mid, data.rid, KeyframeRequestKind::Fir);
-        }
-
-        Propagated::MediaData(self.id, data)
-    }
-
-    fn request_keyframe_throttled(
-        &mut self,
-        mid: Mid,
-        rid: Option<Rid>,
-        kind: KeyframeRequestKind,
-    ) {
-        let Some(mut writer) = self.rtc.writer(mid) else {
-            return;
-        };
-
-        let Some(track_entry) = self.tracks_in.iter_mut().find(|t| t.id.mid == mid) else {
-            return;
-        };
-
-        if track_entry
-            .last_keyframe_request
-            .map(|t| t.elapsed() < Duration::from_secs(1))
-            .unwrap_or(false)
-        {
-            return;
-        }
-
-        _ = writer.request_keyframe(rid, kind);
-
-        track_entry.last_keyframe_request = Some(Instant::now());
-    }
-
     fn handle_incoming_keyframe_req(&self, mut req: KeyframeRequest) -> Propagated {
         // Need to figure out the track_in mid that needs to handle the keyframe request.
         let Some(track_out) = self.tracks_out.iter().find(|t| t.mid() == Some(req.mid)) else {
@@ -653,51 +582,24 @@
             })
             .and_then(|o| o.mid())
         else {
-            info!("rrrrrrrrrrrr");
             return;
         };
 
-        // if data.rid.is_some() && data.rid != Some("h".into()) {
-        //     // This is where we plug in a selection strategy for simulcast. For
-        //     // now either let rid=None through (which would be no simulcast layers)
-        //     // or "h" if we have simulcast (see commented out code in chat.html).
-        //     return;
-        // }
-
-        // Remember this value for keyframe requests.
-        // if self.chosen_rid != data.rid {
-        //     self.chosen_rid = data.rid;
-        // }
-
         let mut dir = self.rtc.direct_api();
-
         let Some(writer) = dir.stream_tx_by_mid(mid, None) else {
-            info!("ggggggggggg");
             return;
         };
 
-        // Match outgoing pt to incoming codec.
-        // let Some(pt) = writer.match_params(data.params) else {
-        //     return;
-        // };
-
-        info!("writeeeeeeeeeeeeeeeeeeeeeeeeeeeee");
-
-        _ = writer.write_rtp(
+        writer.write_rtp(
             packet.header.payload_type,
             packet.seq_no,
-            packet.time.denom(),
+            packet.time.numer() as u32,
             packet.timestamp,
             packet.header.marker,
             packet.header.ext_vals.clone(),
             false,
-            packet.payload.clone(),
-        );
-
-        // if let Err(e) = writer.write(pt, data.network_time, data.time, data.data.clone()) {
-        //     warn!("Client ({}) failed: {:?}", *self.id, e);
-        //     self.rtc.disconnect();
-        // }
+            packet.payload.clone()
+        ).unwrap();
     }
 
     fn handle_keyframe_request(&mut self, req: KeyframeRequest, mid_in: Mid) {
@@ -708,14 +610,18 @@
             return;
         }
 
-        let Some(mut writer) = self.rtc.writer(mid_in) else {
-            return;
-        };
+        let mut dir = self.rtc.direct_api();
+        let stream = dir.stream_rx_by_mid(mid_in, None).unwrap();
+        stream.request_keyframe(KeyframeRequestKind::Pli);
 
-        if let Err(e) = writer.request_keyframe(req.rid, req.kind) {
-            // This can fail if the rid doesn't match any media.
-            info!("request_keyframe failed: {:?}", e);
-        }
+        // let Some(mut writer) = self.rtc.writer(mid_in) else {
+        //     return;
+        // };
+        //
+        // if let Err(e) = writer.request_keyframe(req.rid, req.kind) {
+        //     // This can fail if the rid doesn't match any media.
+        //     info!("request_keyframe failed: {:?}", e);
+        // }
     }
 }
 
Index: examples/chat.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/chat.html b/examples/chat.html
--- a/examples/chat.html	(revision f371a68181237d783b07eb2f1d1d694b29476546)
+++ b/examples/chat.html	(date 1704804276233)
@@ -129,12 +129,12 @@
                 el.srcObject = media;
             }, 1);
             track.addEventListener('mute', () => {
-                console.log('track muted', track);
-                el.parentNode.removeChild(el);
+<!--                console.log('track muted', track);-->
+<!--                el.parentNode.removeChild(el);-->
             });
             track.addEventListener('unmute', () => {
-                console.log('track unmuted', track);
-                byId('media').appendChild(el);
+<!--                console.log('track unmuted', track);-->
+<!--                byId('media').appendChild(el);-->
             });
         };
         async function startRtc() {
